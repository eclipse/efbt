<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<xsd:schema xmlns:column_transformation_logic="http://www.eclipse.org/column_transformation_logic" xmlns:core="http://www.eclipse.org/core" xmlns:cubes="http://www.eclipse.org/cubes" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" xmlns:functions="http://www.eclipse.org/functions" xmlns:transformation="http://www.eclipse.org/transformation" xmlns:trl_sql_views="http://www.eclipse.org/trl_sql_views" xmlns:xsd="http://www.w3.org/2001/XMLSchema" ecore:nsPrefix="trl_sql_views" ecore:package="trl_sql_views" targetNamespace="http://www.eclipse.org/trl_sql_views">
  <xsd:import namespace="http://www.eclipse.org/emf/2002/Ecore" schemaLocation="Ecore.xsd"/>
  <xsd:import namespace="http://www.eclipse.org/transformation" schemaLocation="transformation.xsd"/>
  <xsd:import namespace="http://www.eclipse.org/functions" schemaLocation="functions.xsd"/>
  <xsd:import namespace="http://www.eclipse.org/cubes" schemaLocation="cubes.xsd"/>
  <xsd:import namespace="http://www.eclipse.org/core" schemaLocation="core.xsd"/>
  <xsd:import namespace="http://www.eclipse.org/column_transformation_logic" schemaLocation="column_transformation_logic.xsd"/>
  <xsd:annotation>
    <xsd:documentation>This package describes the set of SQLViews, each SQLView represents a DataSetTransformation which transforms
    data from one DataSet to another in an immutable side-effect free fashion. They use concepts from the well-known SQL StructuredQueryLanguage.
    
    The transformed dataset is created just once by the transformation and then never amended (it is immutable)
    The only data that can be used in the transformation is the data from the source dataset(s), so it cannot use anything else including
    'global variables' (which do not exist in the compitational model, the only data created by the transformation is the data in the resulting transformed dataset,
    no other data is created or affected so the transformations are side-effect free.

</xsd:documentation>
  </xsd:annotation>
  <xsd:annotation>
    <xsd:appinfo ecore:key="license" source="license">Copyright (c) 2020 Bird Software Solutions Ltd
 All rights reserved. This file and the accompanying materials are made available under the terms of the Eclipse Public License v2.0 which accompanies this distribution, and is available at http://www.eclipse.org/legal/epl-v20.html

SPDX-License-Identifier: EPL-2.0 

 Contributors:
 Neil Mackenzie - initial API and implementation&#13;</xsd:appinfo>
  </xsd:annotation>
  <xsd:complexType name="AggregateEnrichmentView">
    <xsd:annotation>
      <xsd:documentation>An SQLView which represents a grouping of  rows of the single source table of the associated table, 
      according to a set of Columns, and creates extra column(s) which runs a specified  aggregation  function over the group.
      This is equivalent to the GroupBy commands in SQL such as select ccy, country, sum(amount) from trades, groupby ccy, country.
      The resulting table structure will be a column for each of the groupBy columns, with one column added per calculated column.
      There will likely be considerably less rows in the results of the view, for example if we are grouping on million trades
      by currency, there will be on row per unique currency in the results.
      All SQLViews are associated with a DerivedCube, the source Cubes for the view are defined by the source Cubes of the associated Cube.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="trl_sql_views:SQLView">
        <xsd:sequence>
          <xsd:element ecore:resolveProxies="true" maxOccurs="unbounded" minOccurs="0" name="functions" type="column_transformation_logic:AggregateColumnFunction">
            <xsd:annotation>
              <xsd:documentation>Aggregated ColumnFunctions</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element ecore:resolveProxies="true" minOccurs="0" name="groupByClause" type="trl_sql_views:GroupByClause">
            <xsd:annotation>
              <xsd:documentation>The GroupBy clause which includes the GroupBy columns</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CopyView">
    <xsd:annotation>
      <xsd:documentation>An SQLView which represents a Copy of all rows of the single source cubw of the associated DereivedCube.
      The resulting Cube Structure will be the same as that source cube.
      The number of rows in the view will be the same as there were in the source cube.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="trl_sql_views:SQLView"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EnrichmentView">
    <xsd:annotation>
      <xsd:documentation>An SQLView which represents a Copy of all rows of the single source cube of the associated DerivedCube,
      and adds one or more calculated columns. 
      The resulting cube structure will be the same as that source cube, with one column added per calculated column,
      although we can choose to Rename some of the columns from the source cube if we wish.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="trl_sql_views:SQLView">
        <xsd:sequence>
          <xsd:element ecore:resolveProxies="true" maxOccurs="unbounded" minOccurs="0" name="functions" type="column_transformation_logic:BasicColumnFunction">
            <xsd:annotation>
              <xsd:documentation>The ColumnFunctions describing how to derive the new columns. Note that their will be a  one to 
              one relationship between the rows in the resulting view and the rows in the source row. So the column function could  
              represent the  addition of 2 columns in the source row for example.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element ecore:resolveProxies="true" maxOccurs="unbounded" minOccurs="0" name="renames" type="trl_sql_views:RenameAs">
            <xsd:annotation>
              <xsd:documentation>A set of Renames, these are similar is concept to the AS command in SQL,
               e.g. in SQL select CCY as Currency from cube1, will mean that the cube structure of the resulting view   has a column called Currency  not CCY, and that cube1 naturally remains with having a column called CCY.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="FilterByConditionView">
    <xsd:annotation>
      <xsd:documentation>An SQLView which represents a Copy of all rows  of the single source cube of the associated cube IF they meet a filter condition.
      The resulting cube structure will be the same as that source cube.
      The number of rows in the view will be the number of rows in the source table that meet the supplied condition.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="trl_sql_views:SQLView">
        <xsd:sequence>
          <xsd:element ecore:resolveProxies="true" minOccurs="0" name="whereClause" type="trl_sql_views:WhereClause">
            <xsd:annotation>
              <xsd:documentation>A WhereClause clause representing the filter condition</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GenericView">
    <xsd:annotation>
      <xsd:documentation>An SQLView which represents a custom transformation.</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="trl_sql_views:SQLView">
        <xsd:sequence>
          <xsd:element ecore:resolveProxies="true" minOccurs="0" name="selectClause" type="trl_sql_views:SelectClause">
            <xsd:annotation>
              <xsd:documentation>A custom select clause</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element ecore:resolveProxies="true" minOccurs="0" name="whereClause" type="trl_sql_views:WhereClause">
            <xsd:annotation>
              <xsd:documentation>A custom where clause</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element ecore:resolveProxies="true" minOccurs="0" name="groupByClause" type="trl_sql_views:GroupByClause">
            <xsd:annotation>
              <xsd:documentation>A custom groupby clause</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GroupByClause">
    <xsd:annotation>
      <xsd:documentation>   This is equivalent to the Group By section  in SQL such as select ccy, country, sum(amount) from trades, group by ccy, country.
      The resulting cube structure will be a column for each of the groupBy columns, with one column added per calculated column.
      There will likely be considerably less rows in the results of the view, for example if we are grouping on million trades
      by currency, there will be on row per unique currency in the results.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:attribute ecore:reference="core:VARIABLE" name="groupByColumns">
      <xsd:annotation>
        <xsd:documentation>the columns to group by </xsd:documentation>
      </xsd:annotation>
      <xsd:simpleType>
        <xsd:list itemType="xsd:anyURI"/>
      </xsd:simpleType>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="IgnoreColumn">
    <xsd:annotation>
      <xsd:documentation> Column to Ignore. Used in a JoinView if we dont want all the columns from the joined cubes to be in the resulting Views cube structure.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:attribute ecore:reference="core:VARIABLE" name="columnToIgnore" type="xsd:anyURI">
      <xsd:annotation>
        <xsd:documentation>the column to Ignore</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute ecore:reference="cubes:FreeBirdToolsCube" name="cube" type="xsd:anyURI">
      <xsd:annotation>
        <xsd:documentation>the cube with the column to ignore.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="JoinView">
    <xsd:annotation>
      <xsd:documentation>An SQLView which represents a join of  rows of  two source cubes of the associated table,  according to a join condition.
This is equivalent to joining 2 tables using  SQL 
The resulting cube structure will be a column for each of the  columns in the 2 source cubes  unless we specify that we want to ignore columns or rename columns.
    
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="trl_sql_views:SQLView">
        <xsd:sequence>
          <xsd:element ecore:resolveProxies="true" minOccurs="0" name="whereClause" type="trl_sql_views:WhereClause">
            <xsd:annotation>
              <xsd:documentation>A WhereClause clause representing the join condition</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element ecore:resolveProxies="true" maxOccurs="unbounded" minOccurs="0" name="renames" type="trl_sql_views:RenameAs">
            <xsd:annotation>
              <xsd:documentation>A rename for each column we wish to rename</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
          <xsd:element ecore:resolveProxies="true" maxOccurs="unbounded" minOccurs="0" name="ignores" type="trl_sql_views:IgnoreColumn">
            <xsd:annotation>
              <xsd:documentation>an IgnoreColumn for each column we want to ignore</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RenameAs">
    <xsd:annotation>
      <xsd:documentation>Column to rename in the resulting View. similar to AS in SQL. Particularly useful if a Join View would result in 2 columns with the same name
      </xsd:documentation>
    </xsd:annotation>
    <xsd:attribute ecore:reference="cubes:FreeBirdToolsCube" name="fromCube" type="xsd:anyURI">
      <xsd:annotation>
        <xsd:documentation>The source cube containing the Column</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute ecore:reference="core:VARIABLE" name="fromVariable" type="xsd:anyURI">
      <xsd:annotation>
        <xsd:documentation>the Column from the source cube that we choose  to Rename in the resulting View</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute ecore:reference="core:VARIABLE" name="toVariable" type="xsd:anyURI">
      <xsd:annotation>
        <xsd:documentation>What Column would we like to use instead.</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="SelectClause">
    <xsd:annotation>
      <xsd:documentation>A Set of Functions representing a select clause in SQL
      </xsd:documentation>
    </xsd:annotation>
    <xsd:attribute ecore:reference="functions:AggregateFunction" name="aggregateFunctions">
      <xsd:annotation>
        <xsd:documentation>Aggregating functions</xsd:documentation>
      </xsd:annotation>
      <xsd:simpleType>
        <xsd:list itemType="xsd:anyURI"/>
      </xsd:simpleType>
    </xsd:attribute>
    <xsd:attribute ecore:reference="functions:BasicFunction" name="basicFunctions" type="xsd:anyURI">
      <xsd:annotation>
        <xsd:documentation>Non-aggregating functions</xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
    <xsd:attribute ecore:reference="core:VARIABLE" name="varaibles">
      <xsd:annotation>
        <xsd:documentation>Column</xsd:documentation>
      </xsd:annotation>
      <xsd:simpleType>
        <xsd:list itemType="xsd:anyURI"/>
      </xsd:simpleType>
    </xsd:attribute>
  </xsd:complexType>
  <xsd:complexType name="SQLView">
    <xsd:annotation>
      <xsd:documentation>An SQLView represents a DataSetTransformation which transforms   data from one DataSet to another in an immutable side-effect free fashion. They use concepts from the well-known SQL StructuredQueryLanguage.
    
    The transformed dataset is created just once by the transformation and then never amended (it is immutable)
    The only data that can be used in the transformation is the data from the source dataset(s), so it cannot use anything else including
    'global variables' (which do not exist in the compitational model, the only data created by the transformation is the data in the resulting transformed dataset,
    no other data is created or affected so the transformations are side-effect free.

</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="transformation:DataSetTransformation">
        <xsd:attribute ecore:name="VTL_Code" name="VTL_Code" type="ecore:EString"/>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UnionView">
    <xsd:annotation>
      <xsd:documentation>An SQLView which represents a Union  of  multiple source cubes of the associated DerivedCube
      .The source cubes must have the same Structure.      This is equivalent to Union of tables in  SQL. 
      The resulting cube structure will be the same as the source cubes and include all the rows from all the source cubes.
    
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="trl_sql_views:SQLView"/>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="VersionedSQLViewsModule">
    <xsd:annotation>
      <xsd:documentation>A module of SQLViews with a version number</xsd:documentation>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="transformation:VersionedTransformationSchemeLogic">
        <xsd:sequence>
          <xsd:element ecore:resolveProxies="true" maxOccurs="unbounded" minOccurs="0" name="sqlViews" type="trl_sql_views:SQLView">
            <xsd:annotation>
              <xsd:documentation>The SQLViews in the module.</xsd:documentation>
            </xsd:annotation>
          </xsd:element>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="WhereClause">
    <xsd:annotation>
      <xsd:documentation>WhereClause contains a boolean function used in filters and joins. This is equivalent to where clause in  SQL.     
    
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element ecore:resolveProxies="true" minOccurs="0" name="function" type="functions:BooleanFunction">
        <xsd:annotation>
          <xsd:documentation>The boolean function</xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:sequence>
  </xsd:complexType>
</xsd:schema>
